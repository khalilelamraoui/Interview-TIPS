# Defining solutions
<hr>

## Introduction
Computer science leverages the power of computers to address real and hypothetical challenges, enabling the virtual exploration and refinement of solutions, replacing traditional, costly methods with efficient problem-solving through precise problem articulation, model formulation, and solution optimization.

## Problem statement
The first step to solving a problem is to articulate it. I need to achieve A, with tools T, given constraints C.<br>
***Say you have to design an app that will entertain a child by playing a guessing game. On the face of it, this seems like a straightforward task: computer + game = happy child. But, before you start, it is worth it to determine some details.***
1. How will the child interact with the computer?
2. What level of questions should be asked?
3. From where are these questions generated?
4. How will they be stored?
5. How will the answers be checked?
6. How will the program start and end?

## Formulate a model 
With identified project constraints, such as a child of a computer-friendly age, laptop-only application, local storage, and keyboard input on the command line, potential solutions can be envisioned. The next step involves defining the computer's tasks within the project scope. Taking an algorithmic approach, the problem is initially generalized, followed by a precise sequence of instructions outlined through pseudocode, aiding the programmer's intuition before actual implementation.

## Finetuning the solution
On reflection, you determine that a trivial knowledge approach will offer too many obstacles so the project is further defined as a number-guessing game. It's appropriate for all ages and there's no need to use external sources. And it should be suitable to implement with most programming languages.<br>
***Having outlined the general requirements, it is possible to fill in the finer points. Below is a flow chart of the pseudocode and it can give further insights into how to best frame the solution.***

<img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/VlYS-DEKSt-Rfn5inK3imQ_cd92fade06b94f5c852648bf41fd3ce1_Pseudocode-01.png?expiry=1703203200000&hmac=g4PimvOntpTNvhDW0IDhfJdjIVy1-F9nPCX-kUJKAiM"/>

***Examining the flowchart identifies further considerations. Will the program run only once? What can be added to enhance the user experience? Printing out a failure message might not be a great output. Instead, an option might be to offer another chance to guess. Further considerations might be to provide prompts that could be used to steer the user toward the correct answer. And, you should decide what happens if the user enters a non-number into the program.***

<img src="https://d3c33hcgiwev3.cloudfront.net/imageAssetProxy.v1/uYlX54nFRUORekdin3aiPA_493c94f831e54d14a486903eb2c121e1_Pseudocode-02.png?expiry=1703203200000&hmac=yREBqNmXnnQJL_xXvisCXWf5ExMuQQWzgBg5YqqjndE"/>

## Conclusion
Computers are a great way to model programs and a means of implementing a solution. It's the programmer's responsibility to employ a systematic approach in developing solutions. The same procedure used to identify a good project for a child can be applied to creating an application for work. It's imperative to establish these good working habits early in your career and to maintain them as your coding proficiency progresses.  
